= 客户端编排器源码分析
:page-pagination:

本文档深入分析 `NettyClientOrchestrator`，它是管理所有客户端实例、生命周期和运行时组件的核心类。

== 架构概览

[source,text]
----
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                              NettyClientOrchestrator                                         │
│                                                                                              │
│  实现接口：                                                                                    │
│  ├── InitializingBean      → afterPropertiesSet() 启动所有客户端                              │
│  ├── DisposableBean        → destroy() 停止所有客户端                                         │
│  └── ApplicationEventPublisherAware → 发布连接/断开事件                                       │
│                                                                                              │
│  核心职责：                                                                                    │
│  ┌───────────────────────────────────────────────────────────────────────────────────────┐  │
│  │  1. 从配置中读取客户端规格（ClientSpec）                                                   │  │
│  │  2. 为每个客户端创建运行时组件：                                                           │  │
│  │     ├── Bootstrap（Netty 客户端引导程序）                                                 │  │
│  │     ├── EventLoopGroup（工作线程组）                                                      │  │
│  │     ├── ConnectionPool（连接池）                                                         │  │
│  │     ├── ReconnectManager（带退避的重连管理）                                               │  │
│  │     ├── HeartbeatManager（保活心跳）                                                      │  │
│  │     └── RequestInvoker（请求/响应关联）                                                   │  │
│  │  3. 管理客户端生命周期（启动、停止）                                                        │  │
│  │  4. 发布生命周期事件                                                                      │  │
│  └───────────────────────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
----

== 源码位置

[source]
----
netty-spring-boot-context/src/main/java/com/childrengreens/netty/spring/boot/context/client/NettyClientOrchestrator.java
----

== 类定义和依赖

[source,java]
----
public class NettyClientOrchestrator
        implements InitializingBean, DisposableBean, ApplicationEventPublisherAware {

    // ============ 依赖项 ============
    private final NettyProperties properties;           // 配置属性
    private final TransportFactory transportFactory;    // 传输层工厂
    private final ClientPipelineAssembler pipelineAssembler;  // Pipeline 组装器
    private final CodecRegistry codecRegistry;          // 编解码器注册表

    // ============ 运行时状态 ============
    private final Map<String, ClientRuntime> runtimes = new ConcurrentHashMap<>();  // 客户端运行时
    private ApplicationEventPublisher eventPublisher;   // 事件发布器
    private ScheduledExecutorService scheduledExecutor; // 调度器（重连、心跳）
    private boolean failFast = true;                    // 启动错误时快速失败
}
----

== 生命周期方法

[source,java]
----
// 在 Spring Bean 初始化后自动调用
@Override
public void afterPropertiesSet() throws Exception {
    start();  // 启动所有客户端
}

// 在 Spring Bean 销毁时自动调用
@Override
public void destroy() throws Exception {
    stop();   // 停止所有客户端
}
----

== 启动流程

=== start() 方法

[source,java]
----
public void start() {
    // 1. 检查是否启用
    if (!properties.isEnabled()) {
        logger.info("Netty is disabled, skipping client startup");
        return;
    }

    // 2. 检查是否配置了任何客户端
    if (properties.getClients().isEmpty()) {
        logger.debug("No clients configured");
        return;
    }

    // 3. 创建共享调度器（用于重连和心跳）
    scheduledExecutor = Executors.newScheduledThreadPool(2, r -> {
        Thread t = new Thread(r, "netty-client-scheduler");
        t.setDaemon(true);
        return t;
    });

    // 4. 遍历所有客户端配置并逐个启动
    for (ClientSpec spec : properties.getClients()) {
        try {
            startClient(spec);
        } catch (Exception e) {
            logger.error("Failed to start client [{}]", spec.getName(), e);
            if (failFast) {
                throw new IllegalStateException("Failed to start client: " + spec.getName(), e);
            }
        }
    }

    logger.info("Started {} Netty client(s)", runtimes.size());
}
----

=== startClient() 方法

[source,java]
----
private void startClient(ClientSpec spec) throws Exception {
    logger.info("Starting client [{}] connecting to {}:{} with profile [{}]",
            spec.getName(), spec.getHost(), spec.getPort(), spec.getProfile());

    // ========== 步骤 1：解析线程配置 ==========
    ThreadsSpec threads = resolveThreads(spec);
    int workerThreads = threads.getWorker();

    // ========== 步骤 2：创建 EventLoopGroup ==========
    EventLoopGroup workerGroup = transportFactory.createWorkerGroup(workerThreads);

    // ========== 步骤 3：获取编解码器 ==========
    NettyCodec codec = codecRegistry.getDefaultCodec();

    // ========== 步骤 4：创建请求调用器 ==========
    RequestInvoker requestInvoker = new RequestInvoker(spec, codec);

    // ========== 步骤 5：创建 Bootstrap ==========
    Bootstrap bootstrap = new Bootstrap();
    bootstrap.group(workerGroup)
            .channel(transportFactory.getClientChannelClass())     // NioSocketChannel
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, (int) spec.getTimeout().getConnectMs())
            .option(ChannelOption.SO_KEEPALIVE, true)
            .option(ChannelOption.TCP_NODELAY, true)
            .handler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel ch) {
                    // ★ 配置 Pipeline
                    pipelineAssembler.assemble(ch.pipeline(), spec, requestInvoker);
                }
            });

    // ========== 步骤 6：创建连接池 ==========
    ConnectionPool connectionPool = new ConnectionPool(spec, bootstrap);

    // ========== 步骤 7：创建重连管理器 ==========
    ReconnectManager reconnectManager = new ReconnectManager(
            spec, bootstrap, connectionPool, scheduledExecutor);
    connectionPool.setReconnectManager(reconnectManager);

    // ========== 步骤 8：创建心跳管理器 ==========
    HeartbeatManager heartbeatManager = new HeartbeatManager(
            spec, connectionPool, requestInvoker, scheduledExecutor);

    // ========== 步骤 9：创建运行时对象 ==========
    ClientRuntime runtime = new ClientRuntime(spec, bootstrap, workerGroup,
            connectionPool, reconnectManager, heartbeatManager, requestInvoker);
    runtime.setState(ClientRuntime.ClientState.RUNNING);

    // ========== 步骤 10：启动心跳（如果配置）==========
    if (spec.getHeartbeat().isEnabled()) {
        heartbeatManager.start();
    }

    // ========== 步骤 11：存储运行时并发布事件 ==========
    runtimes.put(spec.getName(), runtime);
    publishEvent(new NettyClientConnectedEvent(this, spec.getName(), spec.getHost(), spec.getPort()));

    logger.info("Client [{}] started successfully", spec.getName());
}
----

== 关闭流程

=== stop() 方法

[source,java]
----
public void stop() {
    logger.info("Stopping {} Netty client(s)...", runtimes.size());

    // 停止所有客户端
    for (ClientRuntime runtime : runtimes.values()) {
        stopClient(runtime);
    }
    runtimes.clear();

    // 关闭调度器
    if (scheduledExecutor != null) {
        scheduledExecutor.shutdown();
        try {
            if (!scheduledExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduledExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            scheduledExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    logger.info("All Netty clients stopped");
}
----

=== stopClient() 方法

[source,java]
----
private void stopClient(ClientRuntime runtime) {
    logger.info("Stopping client [{}]...", runtime.getName());
    runtime.setState(ClientRuntime.ClientState.STOPPING);

    // 1. 停止心跳
    if (runtime.getHeartbeatManager() != null) {
        runtime.getHeartbeatManager().stop();
    }

    // 2. 停止重连
    if (runtime.getReconnectManager() != null) {
        runtime.getReconnectManager().stop();
    }

    // 3. 关闭连接池
    if (runtime.getConnectionPool() != null) {
        runtime.getConnectionPool().close();
    }

    // 4. 关闭请求调用器
    if (runtime.getRequestInvoker() != null) {
        runtime.getRequestInvoker().close();
    }

    // 5. 关闭工作线程组
    if (runtime.getWorkerGroup() != null) {
        runtime.getWorkerGroup().shutdownGracefully();
    }

    runtime.setState(ClientRuntime.ClientState.STOPPED);

    // 6. 发布断开连接事件
    ClientSpec spec = runtime.getClientSpec();
    publishEvent(new NettyClientDisconnectedEvent(this, runtime.getName(),
            spec.getHost(), spec.getPort(), null));

    logger.info("Client [{}] stopped", runtime.getName());
}
----

== 核心组件

=== ClientRuntime - 运行时信息容器

[source,java]
----
public class ClientRuntime {
    private final ClientSpec clientSpec;           // 客户端配置
    private final Bootstrap bootstrap;             // Netty 引导程序
    private final EventLoopGroup workerGroup;      // 工作线程组
    private final ConnectionPool connectionPool;   // 连接池
    private final ReconnectManager reconnectManager;  // 重连管理器
    private final HeartbeatManager heartbeatManager;  // 心跳管理器
    private final RequestInvoker requestInvoker;   // 请求调用器
    private volatile ClientState state;            // 当前状态

    public enum ClientState {
        CREATED,   // 已创建
        STARTING,  // 启动中
        RUNNING,   // 运行中
        STOPPING,  // 停止中
        STOPPED    // 已停止
    }
}
----

=== ConnectionPool - 连接池

[source,java]
----
public class ConnectionPool {
    // 核心数据结构
    private final BlockingQueue<Channel> idleChannels;        // 空闲连接队列
    private final Set<Channel> borrowedChannels;              // 借出的连接
    private final AtomicInteger totalConnections;             // 总连接数

    // 核心方法
    public Channel acquire() throws Exception {
        // 1. 尝试从空闲队列获取
        Channel channel = idleChannels.poll();
        if (channel != null && isChannelHealthy(channel)) {
            borrowedChannels.add(channel);
            return channel;
        }

        // 2. 尝试创建新连接（如果未达上限）
        if (totalConnections.get() < poolSpec.getMaxConnections()) {
            channel = createChannel();
            borrowedChannels.add(channel);
            return channel;
        }

        // 3. 等待可用连接
        channel = idleChannels.poll(acquireTimeoutMs, TimeUnit.MILLISECONDS);
        if (channel != null) {
            return channel;
        }

        throw new TimeoutException("Timeout waiting for available connection");
    }

    public void release(Channel channel) {
        borrowedChannels.remove(channel);
        if (isChannelHealthy(channel)) {
            idleChannels.offer(channel);
        } else {
            closeChannel(channel);
            // 触发重连
            if (reconnectManager != null) {
                reconnectManager.scheduleReconnect();
            }
        }
    }
}
----

=== ReconnectManager - 指数退避重连管理器

[source,java]
----
public class ReconnectManager {
    private final AtomicInteger retryCount = new AtomicInteger(0);
    private final AtomicLong currentDelay = new AtomicLong(0);

    public void scheduleReconnect() {
        // 调度重连任务
        long delay = currentDelay.get();
        reconnectFuture = scheduler.schedule(this::doReconnect, delay, TimeUnit.MILLISECONDS);
    }

    private void doReconnect() {
        // 检查最大重试次数
        if (maxRetries >= 0 && currentRetry > maxRetries) {
            listener.onReconnectExhausted();
            return;
        }

        // 尝试连接
        ChannelFuture future = bootstrap.connect(host, port);
        if (future.isSuccess()) {
            // 成功：重置状态
            resetState();
            connectionPool.release(future.channel());
        } else {
            // 失败：计算下次延迟（指数退避）
            long nextDelay = (long) (currentDelay.get() * multiplier);
            currentDelay.set(Math.min(nextDelay, maxDelayMs));
            scheduleReconnect();
        }
    }
}
----

==== 指数退避公式

[source,text]
----
delay = min(initialDelay * (multiplier ^ attempt), maxDelay)

示例（initialDelay=1000, multiplier=2.0, maxDelay=30000）：
  第 1 次尝试：1000ms
  第 2 次尝试：2000ms
  第 3 次尝试：4000ms
  第 4 次尝试：8000ms
  第 5 次尝试：16000ms
  第 6 次尝试：30000ms（达到上限）
----

=== HeartbeatManager - 保活心跳管理器

[source,java]
----
public class HeartbeatManager {
    private static final int MAX_CONSECUTIVE_FAILURES = 3;
    private final AtomicInteger consecutiveFailures = new AtomicInteger(0);

    public void start() {
        // 调度周期性心跳
        heartbeatFuture = scheduler.scheduleAtFixedRate(
            this::sendHeartbeat,
            intervalMs,
            intervalMs,
            TimeUnit.MILLISECONDS
        );
    }

    private void sendHeartbeat() {
        Channel channel = connectionPool.acquire();
        try {
            // 发送心跳请求并等待响应
            Object response = requestInvoker.invoke(
                channel, heartbeatType, heartbeatMessage, timeoutMs
            ).get(timeoutMs, TimeUnit.MILLISECONDS);

            // 成功：重置失败计数
            consecutiveFailures.set(0);
        } catch (Exception e) {
            // 失败：增加失败计数
            int failures = consecutiveFailures.incrementAndGet();
            if (failures >= MAX_CONSECUTIVE_FAILURES) {
                // 连续 3 次失败，标记连接不健康
                listener.onConnectionUnhealthy();
                consecutiveFailures.set(0);
            }
        } finally {
            connectionPool.release(channel);
        }
    }
}
----

=== RequestInvoker - 请求/响应关联器

[source,java]
----
public class RequestInvoker {
    public static final String CORRELATION_ID_HEADER = "X-Correlation-Id";
    public static final String MESSAGE_TYPE_HEADER = "type";

    private final ConcurrentMap<String, ResponseFuture<Object>> pendingRequests;

    // 异步调用
    public CompletableFuture<Object> invoke(Channel channel, String type, Object payload, long timeout) {
        String correlationId = UUID.randomUUID().toString().replace("-", "");

        // 创建 Future 并注册
        ResponseFuture<Object> future = new ResponseFuture<>(correlationId, timeout);
        pendingRequests.put(correlationId, future);

        // 构建请求消息
        Map<String, Object> request = new HashMap<>();
        request.put(MESSAGE_TYPE_HEADER, type);
        request.put(CORRELATION_ID_HEADER, correlationId);
        // ... 添加 payload

        // 发送请求
        channel.writeAndFlush(request);

        return future.toCompletableFuture();
    }

    // 完成请求（由 ClientResponseHandler 调用）
    public boolean completeRequest(String correlationId, Object response) {
        ResponseFuture<Object> future = pendingRequests.remove(correlationId);
        if (future != null) {
            return future.complete(response);
        }
        return false;
    }
}
----

== 完整启动流程图

[source,text]
----
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                            NettyClientOrchestrator.start()                                   │
│                                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────────────────────┐  │
│  │  for each ClientSpec in properties.getClients():                                       │  │
│  │                                                                                        │  │
│  │  ┌─────────────────────────────────────────────────────────────────────────────────┐  │  │
│  │  │                          startClient(spec)                                       │  │  │
│  │  │                                                                                  │  │  │
│  │  │  1. 创建 EventLoopGroup（workerGroup）                                            │  │  │
│  │  │     └── transportFactory.createWorkerGroup(workerThreads)                        │  │  │
│  │  │                                                                                  │  │  │
│  │  │  2. 创建 RequestInvoker                                                          │  │  │
│  │  │     └── new RequestInvoker(spec, codec)                                          │  │  │
│  │  │                                                                                  │  │  │
│  │  │  3. 创建 Bootstrap                                                               │  │  │
│  │  │     ├── .group(workerGroup)                                                      │  │  │
│  │  │     ├── .channel(NioSocketChannel.class)                                         │  │  │
│  │  │     ├── .option(CONNECT_TIMEOUT_MILLIS, ...)                                     │  │  │
│  │  │     ├── .option(SO_KEEPALIVE, true)                                              │  │  │
│  │  │     ├── .option(TCP_NODELAY, true)                                               │  │  │
│  │  │     └── .handler(ChannelInitializer)                                             │  │  │
│  │  │            └── pipelineAssembler.assemble(pipeline, spec, requestInvoker)        │  │  │
│  │  │                    ├── Profile.configure() [frameDecoder, frameEncoder]          │  │  │
│  │  │                    ├── addIdleHandler() [IdleStateHandler]                       │  │  │
│  │  │                    ├── addCodecHandler() [JsonCodecHandler]                      │  │  │
│  │  │                    └── add ClientResponseHandler                                 │  │  │
│  │  │                                                                                  │  │  │
│  │  │  4. 创建 ConnectionPool                                                          │  │  │
│  │  │     └── new ConnectionPool(spec, bootstrap)                                      │  │  │
│  │  │                                                                                  │  │  │
│  │  │  5. 创建 ReconnectManager                                                        │  │  │
│  │  │     └── new ReconnectManager(spec, bootstrap, connectionPool, scheduler)         │  │  │
│  │  │                                                                                  │  │  │
│  │  │  6. 创建 HeartbeatManager                                                        │  │  │
│  │  │     └── new HeartbeatManager(spec, connectionPool, requestInvoker, scheduler)    │  │  │
│  │  │                                                                                  │  │  │
│  │  │  7. 创建 ClientRuntime（聚合所有组件）                                             │  │  │
│  │  │     └── new ClientRuntime(spec, bootstrap, workerGroup, connectionPool,          │  │  │
│  │  │                           reconnectManager, heartbeatManager, requestInvoker)    │  │  │
│  │  │                                                                                  │  │  │
│  │  │  8. 启动 HeartbeatManager（如果启用）                                              │  │  │
│  │  │     └── heartbeatManager.start()                                                 │  │  │
│  │  │                                                                                  │  │  │
│  │  │  9. 存储运行时并发布事件                                                           │  │  │
│  │  │     ├── runtimes.put(spec.getName(), runtime)                                    │  │  │
│  │  │     └── publishEvent(NettyClientConnectedEvent)                                  │  │  │
│  │  └─────────────────────────────────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
----

== 组件关系图

[source,text]
----
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                                  ClientRuntime                                               │
│                                                                                              │
│  ┌──────────────┐     ┌──────────────────┐     ┌──────────────────┐                        │
│  │  ClientSpec  │────>│    Bootstrap     │────>│  EventLoopGroup  │                        │
│  │   （配置）    │     │（Netty 引导程序）│     │ （工作线程组）    │                        │
│  └──────────────┘     └──────────────────┘     └──────────────────┘                        │
│         │                      │                                                            │
│         │                      │                                                            │
│         ▼                      ▼                                                            │
│  ┌──────────────────────────────────────────────────────────────────────┐                  │
│  │                        ConnectionPool                                 │                  │
│  │                                                                       │                  │
│  │  ┌─────────────────┐                    ┌─────────────────┐          │                  │
│  │  │  idleChannels   │  ◄── release() ─── │ borrowedChannels │          │                  │
│  │  │  （空闲连接）    │ ─── acquire() ──► │  （借出的连接）   │          │                  │
│  │  └─────────────────┘                    └─────────────────┘          │                  │
│  │                                                                       │                  │
│  │  createChannel() ─► Bootstrap.connect() ─► Pipeline 组装             │                  │
│  └──────────────────────────────────────────────────────────────────────┘                  │
│         │                                           │                                       │
│         │                                           │                                       │
│         ▼                                           ▼                                       │
│  ┌──────────────────┐                    ┌──────────────────────┐                          │
│  │ ReconnectManager │                    │   HeartbeatManager    │                          │
│  │                  │                    │                       │                          │
│  │ - 指数退避       │                    │ - 周期性心跳          │                          │
│  │ - 最大重试次数   │                    │ - 健康检测            │                          │
│  │ - 监听器         │                    │ - 失败阈值            │                          │
│  └──────────────────┘                    └──────────────────────┘                          │
│                                                    │                                        │
│                                                    │                                        │
│                                                    ▼                                        │
│                                          ┌──────────────────────┐                          │
│                                          │   RequestInvoker     │                          │
│                                          │                      │                          │
│                                          │ - 请求/响应关联       │                          │
│                                          │ - 超时处理           │                          │
│                                          │ - correlationId 管理 │                          │
│                                          └──────────────────────┘                          │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
----

== 总结

`NettyClientOrchestrator` 是客户端的核心管理类：

[cols="2,4"]
|===
|职责 |描述

|**配置读取**
|从 `NettyProperties` 读取所有客户端配置

|**组件创建**
|为每个客户端创建 Bootstrap、ConnectionPool、ReconnectManager、HeartbeatManager、RequestInvoker

|**生命周期管理**
|实现 `InitializingBean`/`DisposableBean`，自动启动和停止

|**事件发布**
|发布 `NettyClientConnectedEvent`/`NettyClientDisconnectedEvent`

|**运行时管理**
|通过 `ClientRuntime` 聚合所有组件，提供 `getRuntime(name)` 访问
|===

== 相关类

[cols="2,3"]
|===
|类 |描述

|`ClientRuntime`
|容纳单个客户端所有运行时组件的容器

|`ConnectionPool`
|管理连接池，提供 acquire/release 语义

|`ReconnectManager`
|使用指数退避处理自动重连

|`HeartbeatManager`
|发送周期性心跳以检测死连接

|`RequestInvoker`
|使用关联 ID 关联请求和响应

|`ClientPipelineAssembler`
|为客户端连接组装 Netty Pipeline
|===
