= 连接池
:page-pagination:

客户端使用连接池高效管理 TCP 连接。本页介绍连接池配置、行为、重连和心跳机制。

== 连接池配置

[source,yaml]
----
spring:
  netty:
    clients:
      - name: order-service
        pool:
          maxConnections: 10         # 最大连接数
          minIdle: 2                 # 最小空闲连接
          maxIdleMs: 60000           # 空闲连接最大存活时间
          acquireTimeoutMs: 5000     # 获取连接超时
----

== 连接生命周期

[source,text]
----
acquire() 获取连接:
  1. 检查空闲队列 → 有空闲连接? → 返回
  2. 检查连接池大小 → 未达上限? → 创建新连接
  3. 等待可用连接 → 超时? → 抛出异常

release() 释放连接:
  1. 健康检查 → 连接有效? → 返回空闲队列
  2. 连接无效 → 关闭并触发重连
----

== 自动重连

[source,yaml]
----
spring:
  netty:
    clients:
      - name: order-service
        reconnect:
          enabled: true
          initialDelayMs: 1000       # 初始重连延迟
          maxDelayMs: 30000          # 最大重连延迟
          multiplier: 2.0            # 指数退避乘数
          maxRetries: -1             # 最大重试次数 (-1=无限)
----

=== 指数退避

[source,text]
----
连接断开!

重试 1: 等待 1000ms  → 连接... 失败
重试 2: 等待 2000ms  → 连接... 失败
重试 3: 等待 4000ms  → 连接... 失败
重试 4: 等待 8000ms  → 连接... 失败
重试 5: 等待 16000ms → 连接... 失败
重试 6: 等待 30000ms → 连接... 成功! (达到最大延迟)
----

公式: `delay = min(initialDelay * (multiplier ^ attempt), maxDelay)`

== 心跳

[source,yaml]
----
spring:
  netty:
    clients:
      - name: order-service
        heartbeat:
          enabled: true
          intervalMs: 30000          # 心跳间隔
          timeoutMs: 5000            # 心跳超时
          message: '{"type":"heartbeat"}'
----

心跳流程：

1. 每 30 秒发送心跳消息
2. 等待响应 (最多 5 秒)
3. 响应成功 → 连接健康
4. 连续 3 次失败 → 标记连接不健康

== 监控指标

可通过 Actuator 获取连接池指标：

[source,bash]
----
GET /actuator/netty/clients/order-service
----

[source,json]
----
{
  "name": "order-service",
  "status": "CONNECTED",
  "pool": {
    "maxConnections": 10,
    "currentSize": 8,
    "activeCount": 3,
    "idleCount": 5,
    "pendingAcquire": 0
  }
}
----
